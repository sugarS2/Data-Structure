/**
 ---------------------------------------------------------------------------------------------------------------
 
 ■ 제한된 제네릭(Generic)과 와일드카드(WildCard)
   - 제네릭은 참조 타입 모두 될 수 있다. 
    ex. 타입T : 외부클래스에서 Integer를 보내면 T는 Integer, String을 보내면 T는 String이 된다. (A클래스를 T파라미터로 보내면 T는 A클래스가 된다)
   - 만약 특정 범위 내로 좁혀서 제한하고 싶은 경우? 
   -> 'extends, super, ?(물음표=와일드카드)' 를 사용한다. 

1. 설명
extends T : 상한 경계
? super T : 하한 경계 
<?>       : 와일드카드 (Wild Card)

2. 코드 
<K extends T>    // T와 T의 자손타입만 가능 (K는 들어오는 타입으로 지정됨) 
<K super T>      // T와 T의 부모(조상)타입만 가능 (K는 들어오는 타입으로 지정됨)

<? extends T>    // T와 T의 자손타입만 가능 
<? super T>      // T와 T의 부모(조상)타입만 가능 
<?>              // 모든 타입 가능. <? extends Object> 랑 같은 의미

3. 'K extends T' 와 '? extends T' 의 차이점
 - 공통점 : 유형 경계를 지정한다. (즉, T와 T의 자손타입만 가능)
 - 차이점 : K 는 특정타입으로 지정이 되지만, ? 는 타입이 지정되지 않는다. 
 - 예시1.
   (1) <K extends Number>
       Number와 이를 상속하는 Integer, Short, Double, Long 등의 타입이 지정될 수 있으며, 
       객체 혹은 메소드를 호출할 경우, K는 지정된 타입으로 변환이 된다. 
   (2) <? extends T>
       Number와 이를 상속하는 Integer, Short, Double, Long 등의 타입이 지정될 수 있으며, 
       객체 혹은 메소드를 호출할 경우, 지정되는 타입이 없어 타입 참조를 할 수는 없다. 
   -> 위와 같은 차이가 있기 때문에, 
      특정 타입의 데이터를 조작하고자 할 경우에는 K와 같이 특정 제네릭 인수로 지정을 해주어야 한다. 

4. extends 와 super 
 4-1. extends 상속관계 
    * 구조 : A - B - C
            └ - D - E
    * 코드 
      <T extends B>, <? extends B>   // B와 C 타입만 올 수 있음 
      <T extends E>, <? extends E>   // E 타입만 올 수 있음 
      <T extends A>, <? extends A>   // A,B,C,D,E 타입이 올 수 있음 
 4-2. super 관계 
    * 구조 : 예시2-1 구조 참고 
    * 코드 
      <T super B>, <? super B>   // B와 A 타입만 올 수 있음
      <T super E>, <? super E>   // E,D,A 타입만 올 수 있음 
      <T super A>, <? super A>   // A 타입만 올 수 있음 
    * 사용 예시 : 제네릭 타입에 대한 객체 비교 
      <E extends Comparable<? super E>> : E 자기자신 및 조상타입과 비교할 수 있는 E
 ---------------------------------------------------------------------------------------------------------------
 */